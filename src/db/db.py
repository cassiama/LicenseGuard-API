import os
from dataclasses import dataclass
from typing import Optional, Protocol
from datetime import datetime
from contextlib import asynccontextmanager
from fastapi import FastAPI, Request
from srv.schemas import ProjectRecord, Status


# ----- Basic DB protocol so you can swap real/Mock easily -----

class DBClient(Protocol):
    async def connect(self) -> None: ...
    async def disconnect(self) -> None: ...
    # Examples of operations you might implement:
    async def upsert_project(self, record: ProjectRecord) -> None: ...
    async def get_project(self, project_id: str) -> Optional[ProjectRecord]: ...
    async def set_status(self, project_id: str, status: Status) -> None: ...


# ----- Mock client (no persistence performed) -----

class MockDBClient:
    def __init__(self) -> None:
        self._store: dict[str, ProjectRecord] = {}

    async def connect(self) -> None:
        print(f"[{datetime.now()}]: URL to database not provided. Connected to non-persistent database (fallback).")

    async def disconnect(self) -> None:
        print(f"[{datetime.now()}]: Disconnecting from database. All data will be deleted. Goodbye!")
        self._store.clear()

    # Example operations (no-ops / in-memory)
    async def upsert_project(self, record: ProjectRecord) -> None:
        self._store[record.id] = record

    async def get_project(self, project_id: str) -> Optional[ProjectRecord]:
        return self._store.get(project_id)

    async def set_status(self, project_id: str, status: Status) -> None:
        if project_id in self._store:
            self._store[project_id].status = status


# NOTE: this is a placeholder class (generated by GPT-5); the real DB client (probably psycopg) will go here
@dataclass
class RealDBClient:
    url: str

    async def connect(self) -> None:
        # e.g., create SQLAlchemy engine/pool here
        # engine = create_async_engine(self.url, pool_pre_ping=True, ...)
        # self._engine = engine
        pass

    async def disconnect(self) -> None:
        # await self._engine.dispose()
        pass

    async def upsert_project(self, record: ProjectRecord) -> None:
        # Implement UPSERT logic
        pass

    async def get_project(self, project_id: str) -> Optional[ProjectRecord]:
        # Implement SELECT logic
        return None

    async def set_status(self, project_id: str, status: Status) -> None:
        # Implement UPDATE logic
        pass


# factory for DB clients
def create_db_client() -> DBClient:
    db_url = os.getenv("DB_URL", "").strip()
    if db_url:
        return RealDBClient(url=db_url)
    return MockDBClient()


# app lifespan binding
_db_client: Optional[DBClient] = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    db = create_db_client()
    app.state.db = db
    # try to connect in case "create_db_client" returns nothing in some environments
    if db and hasattr(db, "connect"):
        await db.connect()
    try:
        yield
    finally:
        if db and hasattr(db, "disconnect"):
            await db.disconnect()
        app.state.db = None  # prevent leakage between TestClients


# dependency for FastAPI routes
def get_db(request: Request) -> DBClient:
    db = getattr(request.app.state, "db", None)
    if db is None:
        # raise a server error if the database is not initialized
        raise RuntimeError("DB is not initialized.")
    return db
