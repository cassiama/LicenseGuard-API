import os
from dataclasses import dataclass
from typing import Optional, Protocol, TypedDict, cast
from datetime import datetime
from contextlib import asynccontextmanager
from uuid import UUID, uuid4
from fastapi import FastAPI, Request
from srv.schemas import Event, EventType, User
from srv.security import get_hashed_pwd


# NOTE: this dictionary is temporary and acts as our dummy database table.
#       in the real app, this would be a connection to PostgreSQL.
class UserDict(TypedDict):
    id: UUID
    username: str
    full_name: str
    email: str
    hashed_password: str


FAKE_USERS_DB: dict[str, UserDict] = {
    "johndoe": {
        "id": uuid4(),
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "hashed_password": get_hashed_pwd("secret"),
    }
}


# ----- Basic DB protocol so you can swap real/Mock easily -----
class DBClient(Protocol):
    async def connect(self) -> None: ...
    async def disconnect(self) -> None: ...
    # The new primary method is to log an event
    async def upsert_event(self, record: Event) -> None: ...
    # A helper to get all events for a project, which can be useful

    async def get_project_events(
        self, user_id: UUID, project_name: str
    ) -> list[Event]: ...


# ----- Mock client (no persistence performed) -----

class MockDBClient:
    def __init__(self) -> None:
        self._store: list[Event] = []

    async def connect(self) -> None:
        print(f"[{datetime.now()}]: Connected to non-persistent database (fallback).")

    async def disconnect(self) -> None:
        print(
            f"[{datetime.now()}]: Disconnecting from database. All data will be deleted.")
        self._store.clear()

    async def upsert_event(self, record: Event) -> None:
        """Adds a new event to the in-memory list."""
        print(
            f"[{datetime.now()}]: {record.event} for project {record.project_name}.")
        self._store.append(record)

    async def get_project_events(
        self, user_id: UUID, project_name: str
    ) -> list[Event]:
        """Filters the list to find all events for a specific project and user."""
        return [
            event for event in self._store
            if event.user_id == user_id and event.project_name == project_name
        ]


# NOTE: this is a placeholder class (generated by GPT-5); the real DB client (probably psycopg) will go here
@dataclass
class RealDBClient:
    url: str

    async def connect(self) -> None:
        # e.g., create SQLAlchemy engine/pool here
        # engine = create_async_engine(self.url, pool_pre_ping=True, ...)
        # self._engine = engine
        pass

    async def disconnect(self) -> None:
        # await self._engine.dispose()
        pass

    async def upsert_event(self, record: Event) -> None:
        # Implement UPSERT logic
        pass

    async def get_project_events(
        self,
        user_id: UUID,
        project_name: str
    ) -> list[Event]:
        # Implement SELECT logic
        return [Event(id=uuid4(), user_id=uuid4(), project_name="", event=EventType.PROJECT_CREATED)]


# factory for DB clients
def create_db_client() -> DBClient:
    db_url = os.getenv("DB_URL", "").strip()
    if db_url:
        return RealDBClient(url=db_url)
    return MockDBClient()


# app lifespan binding
_db_client: Optional[DBClient] = None


@asynccontextmanager
async def lifespan(app: FastAPI):
    db = create_db_client()
    app.state.db = db
    # try to connect in case "create_db_client" returns nothing in some environments
    if db and hasattr(db, "connect"):
        await db.connect()
    try:
        yield
    finally:
        if db and hasattr(db, "disconnect"):
            await db.disconnect()
        app.state.db = None  # prevent leakage between TestClients


# dependency for FastAPI routes
def get_db(request: Request) -> DBClient:
    db = getattr(request.app.state, "db", None)
    if db is None:
        # raise a server error if the database is not initialized
        raise RuntimeError("DB is not initialized.")
    return db


# functions to be used for user authentication:
def get_user_by_username(username: str) -> Optional[User]:
    """
    Retrieves a single user from the database by their username.
    """
    if username in FAKE_USERS_DB:
        return User(**FAKE_USERS_DB[username])
    return None


def save_user(user: User) -> User:
    """
    Saves a user to the database.
    """
    # TODO: replace this code once you have a working database connection
    # we cast this because `model_dump()` returns a generic dict while FAKE_USERS_DB expects a TypedDict/UserDict
    FAKE_USERS_DB[user.username] = cast(UserDict, user.model_dump())
    return user
